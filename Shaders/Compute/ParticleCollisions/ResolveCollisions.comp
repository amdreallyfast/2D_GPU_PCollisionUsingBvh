// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticlePotentialCollisionsBuffer.comp
// REQUIRES ParticlePropertiesBuffer.comp
// REQUIRES ParticleBuffer.comp

// Y and Z work group sizes default to 1
layout (local_size_x = WORK_GROUP_SIZE_X) in;


/*------------------------------------------------------------------------------------------------
Description:
    For elastic collisions between two different masses (ignoring rotation because these 
    particles are points), use the calculations from this article (I followed them on paper too 
    and it seems legit)
    http://www.gamasutra.com/view/feature/3015/pool_hall_lessons_fast_accurate_.php?page=3

    Note: For an elastic collision between two particles of equal mass, the velocities of the 
    two will be exchanged.  I could use this simplified idea for this demo, but I want to 
    eventually have the option of different masses of particles, so I will use the general 
    case elastic collision calculations (bottom of page at link).
    http://hyperphysics.phy-astr.gsu.edu/hbase/colsta.html

Parameters: None
Returns:    None
Creator:    John Cox, 5/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex >= uMaxNumParticles)
    {
        return;
    }
    else if (AllParticles[threadIndex]._isActive == 0)
    {
        return;
    }

    Particle p1 = AllParticles[threadIndex];
    ParticleProperties p1Properties = AllParticleProperties[p1._particleTypeIndex];

    // TODO: position shift
    vec4 p1NetDeltaVelocity = vec4(0.0f, 0.0f, 0.0f, 0.0f);

    // make a local copy for easier access
    ParticlePotentialCollisions collisionCandidates = AllParticlePotentialCollisions[threadIndex];

    // go through all the collision candidates, and if necessary calculate collision results
    for (int particleIndexCounter = 0; 
        particleIndexCounter < collisionCandidates._numPotentialCollisions; 
        particleIndexCounter++)
    {
        //p1NetDeltaVelocity.y += 0.1f;

        int p2Index = collisionCandidates._particleIndexes[particleIndexCounter];
        Particle p2 = AllParticles[p2Index];
        ParticleProperties p2Properties = AllParticleProperties[p2._particleTypeIndex];

        // check for actual collision
        // Note: The bounding boxes overlapped, but particles have circular collision regions.
        float r1 = p1Properties._collisionRadius;
        float r2 = p2Properties._collisionRadius;
        float minDistForCollisionSqr = (r1 + r2) * (r1 + r2);

        // Note: The W component should be 0 after the subtraction, but orce it to 0 just in case so it doesn't mess up the square of the magnitude.
        // ??Also Note: what happens if I do p2 - p1??
        vec4 lineOfContact = vec4(p1._pos.xyz - p2._pos.xyz, 0.0f);
        float distSqr = dot(lineOfContact, lineOfContact);
        if (distSqr > minDistForCollisionSqr)
        {
            // close, but no cigar
            continue;
        }

        // Note: Momentum will only be exchanged along the line of contact.  Dot products will be taken to find the magnitudes of each particles' velocity along the line of contact, so normalize this line of contact.
        // Also Note: The velocities along the line of contact are called "a1" and "a2", respectively, in the Gamasutra article.  Because overly simplified variable names are apparently par for the course :(.
        vec4 normalizedLineOfContact = lineOfContact * inversesqrt(distSqr);
        float p1VelOnLineOfContact = dot(p1._vel, normalizedLineOfContact);
        float p2VelOnLineOfContact = dot(p2._vel, normalizedLineOfContact);

        // Note: This comes from the Gamasutra article's conservation of momentum combined with breakdowns of the velocity vectors along the line of contact.  It is referred to in the end as "optimizedP", but it is no longer momentum.  It saddens me that the term P, which referred to momentum, is now used to describe velocity/mass, which is the 
        // TODO: inverse mass, calculate P, then multiply by the appropriate inverse mass
        float massFraction = (p1Properties._mass / (p1Properties._mass + p2Properties._mass));
        float deltaMomentum = massFraction * (2.0f * (p1VelOnLineOfContact - p2VelOnLineOfContact));
        
        p1NetDeltaVelocity += ((-1.0f) * deltaMomentum * normalizedLineOfContact);
        


//        // didn't continue, so there is a collision
//        // Note: I don't have an intuitive understanding of these calculations, but they work.  
//        // If I understood it better, then I could write better comments and variable names, but 
//        // I don't, so I'm keeping it the way that I found it in the gamasutra article, or at 
//        // least as much as I can given that it is math and pseudocode.
//        
//
//        //p1NetDeltaVelocity += normalizedLineOfContact;
//
//        float a1 = dot(p1._vel, p1ToP2);
//        float a2 = dot(p2._vel, p1ToP2);
//        float fraction = (2.0f * (a1 - a2)) / (p1Properties._mass + p2Properties._mass);
//        vec4 p1DeltaVelocity = (-1.0f) * (fraction * p2Properties._mass * normalizedLineOfContact);
//        
//        // if there are multiple collisions, this may end up with a very high velocity (
//        // collisions from one side) or a very low velocity (collisions from all sides), but 
//        // most likely it will be somewhere in the middle
//        p1NetDeltaVelocity += p1DeltaVelocity;
    }
    
    //if (collisionCandidates._numPotentialCollisions != 0)
    //{
    //    AllParticles[threadIndex]._vel *= -1.0f;
    //}
    AllParticles[threadIndex]._vel += p1NetDeltaVelocity;


    //
    //if 
    //
    //
    //
    //
    //// this value is set at the end of DetectCollisions.comp
    //// Note: DetectCollisions.comp also performs a check to make sure that the two particles' 
    //// collision spheres intersect, not just their bounding boxes.
    //int otherGuyIndex = AllParticles[threadIndex]._collideWithThisParticleIndex;
    //if (otherGuyIndex == -1)
    //{
    //    return;
    //}
    //
    //// local copies will be easier to work with
    //Particle p1 = AllParticles[threadIndex];
    //Particle p2 = AllParticles[otherGuyIndex];
    //
    //// Note: I don't have an intuitive understanding of these calculations, but they work.  If I 
    //// understood it better, then I could write better comments and variable names, but I don't, 
    //// so I'm keeping it the way that I found it in the gamasutra article, or at least as much 
    //// as I can given that it is math and pseudocode.
    //vec4 p1ToP2 = vec4(p2._pos.xyz - p1._pos.xyz, 0.0f);
    //vec4 normalizedLineOfContact = p1ToP2 * inversesqrt(dot(p1ToP2, p1ToP2));
    //float a1 = dot(p1._vel, p1ToP2);
    //float a2 = dot(p2._vel, p1ToP2);
    //float fraction = (2.0f * (a1 - a2)) / (p1._mass + p2._mass);
    //vec4 p1VelocityPrime = p1._vel - (fraction * p2._mass * normalizedLineOfContact);
    //vec4 p2VelocityPrime = p2._vel + (fraction * p1._mass * normalizedLineOfContact);
    //
    //// write results back to global memory
    ////??how to only have one thread handle both conditions without a race condition? atomicAdd(...) on a dedicated member? should I even other? what if the other particle had a better collision /with /someone else??
    //AllParticles[threadIndex]._vel = p1VelocityPrime;
    //AllParticles[otherGuyIndex]._vel = p2VelocityPrime;
}
