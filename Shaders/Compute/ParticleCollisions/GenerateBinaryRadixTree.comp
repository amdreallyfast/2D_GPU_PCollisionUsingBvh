// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
// REQUIRES BvhNodeBuffer.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;


// see CLZ1(...) comment block for credit
// Note: This array is a key part of CLZ1, which in turn is a key part of LengthOfCommonPrefix
// (...), which in turn is a key part of the binary radix tree construction.  Let it be a global 
// in this shader, and make it shared to prevent copies from hogging more memory than necessary 
// (it's honestly not much, but still).
// Also Note: ??why can't I make it shared? why is there an error about "might be used before it is initialized"??
const int[] clz_lkup = 
{
    32, 31, 30, 30, 29, 29, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28,
    27, 27, 27, 27, 27, 27, 27, 27,
    27, 27, 27, 27, 27, 27, 27, 27,
    26, 26, 26, 26, 26, 26, 26, 26,
    26, 26, 26, 26, 26, 26, 26, 26,
    26, 26, 26, 26, 26, 26, 26, 26,
    26, 26, 26, 26, 26, 26, 26, 26,
    25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24
};

/*------------------------------------------------------------------------------------------------
Description:
    Algorithm credit goes to Miro Samek with Embedded Gurus.
    http://embeddedgurus.com/state-space/2014/09/fast-deterministic-and-portable-counting-leading-zeros/

    I adapted it for use in an OpenGL compute shader.

    Note: This algorithm works by figuring out which byte has the most significant 1 bit.  Then 
    the whole thing is bit shifted so that the byte with the most significant 1 is in byte 0 of 
    the 32bit integer (all trailing bits are considered irrelevant).  This makes the most 
    significant byte on the range 0-255.  The "clz_lkup" array has 256 values.  These values are 
    the number of leading zeros for every single possible value on range 0-255.  This is less of 
    a calculation and more of a lookup.  And it's a fast lookup.
    
    Also Note: Miro Samek also posted a CLZ2(...) function in the same article.  That function 
    is meant for embedded systems that are severely limited in ROM and are willing to sacrifice 
    a little run speed for a smaller clz_lkup[] footprint.  I am not running this on an embedded 
    system and have no problems with available memory, so I will keep using CLZ1(...).
Parameters: 
    x   The value to analyze.
Returns:    
    The number of leading zeros in the 32bit unsigned integer
Creator:    John Cox, 5/2017
------------------------------------------------------------------------------------------------*/
int CLZ1(uint x) {
    int n = 0;
    if (x >= (1U << 16)) {
        if (x >= (1U << 24)) {
            n = 24;
        }
        else {
            n = 16;
        }
    }
    else {
        if (x >= (1 << 8)) {
            n = 8;
        }
        else {
            n = 0;
        }
    }
    return clz_lkup[x >> n] - n;
}

/*------------------------------------------------------------------------------------------------
Description:
    Calculates the number of leading bits that the two arguments have in common.

    Ex: 0b00001 and 0b10001
    The common prefix is length 0.  There are three bits in common, but they are not leading 
    bits.

    This is part of the binary radix tree generation described in this paper:
    http://devblogs.nvidia.com/parallelforall/wp-content/uploads/2012/11/karras2012hpg_paper.pdf

    This method performs the job of the pseudocode's sigma.  

    Note: The paper said to, if the values were equal, concatenate the bits of the index to the 
    bits of the values being analyzed and then then determine the longest common prefix.  This 
    implementation only lives in 32bit land, so I can't concatenate a 32bit value to another 
    32bit value.  There aren't enough bits.  I'd need a a 64bit uint for that.  But I can 
    determine the longest common prefix of the values and of their indices and then add the two 
    together if necessary.  The CLZ1(...) function is fast enough to make performance not a 
    concern.
    
    Also Note: I discovered by experimentation that always adding the lenght of the common 
    prefixes together messed up the tree.  So only add the length of the common prefix if the 
    values are equal.

    Ex 1: 
        // suppose our integers live in 5bit land
        value1 at indexA = 0b00010
        value2 at indexB = 0b01111
        longest common prefix = 1 (the most significant bit)

    Ex 2:
        // equal values get special handling
        value1 at indexA = 0b11010
        value2 at indexB = 0b11010
        length of common prefix = 5 (all bits identical)
        let indexA = 13 = 0b01101
        let indexB = 14 = 0b01110
        length of common prefix = 3 (most significant bits)
        reported common prefix length = 5 + 3 = 8;

Parameters: 
    indexA  An index into the "leaf" section of AllBvhNodes.  Expected to be thread ID.
    indexB  Another index into the "leaf" section of AllBvhNodes.
Returns:    
    See Description.
Creator:    John Cox, 5/2017
------------------------------------------------------------------------------------------------*/
int LengthOfCommonPrefix(int indexA, int indexB)
{
    // don't need to check 'a' because that is a thread ID and therefore should always be in 
    // bounds
    // Note: It seems that a >= comparison between int and uint is ok, no cast required.
    if (indexB < 0 || indexB >= uNumActiveParticles)
    {
        return -1;
    }

    uint valueA = AllBvhNodes[indexA]._data;
    uint valueB = AllBvhNodes[indexB]._data;

    // the XOR will highlight the bits that are different, thus leaving as 0s all the bits that 
    // are identical
    int valueNumCommonBits = CLZ1(valueA ^ valueB);
    int indexNumCommonBits = CLZ1(indexA ^ indexB);
    //return (valueA == valueB) ? valueNumCommonBits + indexNumCommonBits : valueNumCommonBits;
    return (valueA == valueB) ? 32 + indexNumCommonBits : valueNumCommonBits;

//    int commonPrefixLength = 0;
//    if ((valueA ^ valueB) == 0)
//    {
//        commonPrefixLength = 32;    // 2x identical integers
//        commonPrefixLength += (32 - int(floor(log2(indexA ^ indexB)) + 1));
//    }
//    else
//    {
//        commonPrefixLength = 32 - int(floor(log2(valueA ^ valueB)) + 1);
//    }
//    return commonPrefixLength;
}

/*------------------------------------------------------------------------------------------------
Description:
    Determines how many leaves this internal node covers, minus 1.  I don't have an intuitive 
    explanation, but the math works out.  The number of nodes covered depends on depth into the 
    tree.

    Part of the binary radix tree generation described in this paper:
    http://devblogs.nvidia.com/parallelforall/wp-content/uploads/2012/11/karras2012hpg_paper.pdf

    This is only called once by main(), but I thought that it made the algorithm easier to read 
    if this part of it was off in its own function.

    Note: It may be possible to find the length ("range", or number of leaf nodes that this 
    internal node covers) in a single loop, but the only way that I'm aware of is a linear 
    search through all items.  The whole point of a binary search is to reduce an O(n) solution 
    to O(log n), so keep the 2-loop solution.

Parameters: 
    startNodeIndex  An index into the internal node section of the BvhNodeBuffer.
    direction       -1 or +1.  If it is 0, something has gone terribly wrong.
Returns:    
    See Description.
Creator:    John Cox, 5/2017
------------------------------------------------------------------------------------------------*/
int DetermineRange(int startNodeIndex, int direction)
{
    // determine how many leaves this internal node covers ("range") 
    int minimumCommonPrefixLength = LengthOfCommonPrefix(startNodeIndex, startNodeIndex - direction);
    
    int maxPossibleLength = 2;
    int secondNodeIndex = startNodeIndex + (maxPossibleLength * direction);
    while (LengthOfCommonPrefix(startNodeIndex, secondNodeIndex) > minimumCommonPrefixLength)
    {
        maxPossibleLength *= 2;
        secondNodeIndex = startNodeIndex + (maxPossibleLength * direction);
    }

    // find actual length using a binary search on the max possible length
    int actualLengthSans1 = 0;
    for (int rangeIncrement = maxPossibleLength >> 1; rangeIncrement >= 1; rangeIncrement >>= 1)
    {
        secondNodeIndex = startNodeIndex + ((actualLengthSans1 + rangeIncrement) * direction);
        if (LengthOfCommonPrefix(startNodeIndex, secondNodeIndex) > minimumCommonPrefixLength)
        {
            actualLengthSans1 += rangeIncrement;
        }
    }

    return actualLengthSans1;


//    int internalNodeIndex = int(uBvhNumberLeaves) + startNodeIndex;
//
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._minPrefix._indexA = startNodeIndex;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._minPrefix._indexB = startNodeIndex - direction;
//    uint val1 = AllBvhNodes[startNodeIndex]._data;
//    uint val2 = AllBvhNodes[startNodeIndex - direction]._data;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._minPrefix._valueA = val1;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._minPrefix._valueB = val2;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._minPrefix._xor = val1 ^ val2;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._minPrefix._commonPrefixLength = minimumCommonPrefixLength;
//
//    int maxPossibleLength = 2;
//    int secondNodeIndex = startNodeIndex + (maxPossibleLength * direction);
//    int commonPrefixLength = LengthOfCommonPrefix(startNodeIndex, secondNodeIndex);
//    int loopCounter = 0;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._lengthBefore = maxPossibleLength;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._indexA = startNodeIndex;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._indexB = secondNodeIndex;
//    val1 = AllBvhNodes[startNodeIndex]._data;
//    val2 = AllBvhNodes[secondNodeIndex]._data;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._valueA = val1;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._valueB = val2;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._xor = val1 ^ val2;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._commonPrefixLength = commonPrefixLength;
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._lengthAfter = maxPossibleLength;
//
//    while (commonPrefixLength > minimumCommonPrefixLength)
//    {
//        maxPossibleLength *= 2;
//        AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._lengthAfter = maxPossibleLength;
//
//        secondNodeIndex = startNodeIndex + (maxPossibleLength * direction);
//        commonPrefixLength = LengthOfCommonPrefix(startNodeIndex, secondNodeIndex);
//        loopCounter++;
//
//        AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._lengthBefore = maxPossibleLength;
//        AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._indexA = startNodeIndex;
//        AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._indexB = secondNodeIndex;
//        val1 = AllBvhNodes[startNodeIndex]._data;
//        val2 = AllBvhNodes[secondNodeIndex]._data;
//        AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._valueA = val1;
//        AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._valueB = val2;
//        AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._xor = val1 ^ val2;
//        AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._prefixLength._commonPrefixLength = commonPrefixLength;
//        AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter]._lengthAfter = maxPossibleLength;
//    }
//    AllBvhNodes[internalNodeIndex]._findMaxLengthDebug._iterations[loopCounter+1]._lengthBefore = 37;
//
//
//
//    AllBvhNodes[internalNodeIndex]._findOtherEndDebug._minPrefix._indexA = startNodeIndex;
//    AllBvhNodes[internalNodeIndex]._findOtherEndDebug._minPrefix._indexB = startNodeIndex - direction;
//    val1 = AllBvhNodes[startNodeIndex]._data;
//    val2 = AllBvhNodes[startNodeIndex - direction]._data;
//    AllBvhNodes[internalNodeIndex]._findOtherEndDebug._minPrefix._valueA = val1;
//    AllBvhNodes[internalNodeIndex]._findOtherEndDebug._minPrefix._valueB = val2;
//    AllBvhNodes[internalNodeIndex]._findOtherEndDebug._minPrefix._xor = val1 ^ val2;
//    AllBvhNodes[internalNodeIndex]._findOtherEndDebug._minPrefix._commonPrefixLength = minimumCommonPrefixLength;
//    loopCounter = 0;
//
//    // find actual length using a binary search on the max possible length
//    int actualLengthSans1 = 0;
//    for (int rangeIncrement = maxPossibleLength >> 1; rangeIncrement >= 1; rangeIncrement >>= 1)
//    {
//        secondNodeIndex = startNodeIndex + ((actualLengthSans1 + rangeIncrement) * direction);
//        int commonPrefixLength = LengthOfCommonPrefix(startNodeIndex, secondNodeIndex);
//
//        AllBvhNodes[internalNodeIndex]._findOtherEndDebug._iterations[loopCounter]._lengthBefore = actualLengthSans1;
//        AllBvhNodes[internalNodeIndex]._findOtherEndDebug._iterations[loopCounter]._prefixLength._indexA = startNodeIndex;
//        AllBvhNodes[internalNodeIndex]._findOtherEndDebug._iterations[loopCounter]._prefixLength._indexB = secondNodeIndex;
//        val1 = AllBvhNodes[startNodeIndex]._data;
//        val2 = AllBvhNodes[secondNodeIndex]._data;
//        AllBvhNodes[internalNodeIndex]._findOtherEndDebug._iterations[loopCounter]._prefixLength._valueA = val1;
//        AllBvhNodes[internalNodeIndex]._findOtherEndDebug._iterations[loopCounter]._prefixLength._valueB = val2;
//        AllBvhNodes[internalNodeIndex]._findOtherEndDebug._iterations[loopCounter]._prefixLength._xor = val1 ^ val2;
//        AllBvhNodes[internalNodeIndex]._findOtherEndDebug._iterations[loopCounter]._prefixLength._commonPrefixLength = commonPrefixLength;
//        if (commonPrefixLength > minimumCommonPrefixLength)
//        {
//            actualLengthSans1 += rangeIncrement;
//        }
//        AllBvhNodes[internalNodeIndex]._findOtherEndDebug._iterations[loopCounter]._lengthAfter = actualLengthSans1;
//
//        loopCounter++;
//    }
//    AllBvhNodes[internalNodeIndex]._findOtherEndDebug._iterations[loopCounter+1]._lengthBefore = 37;
//
//    return actualLengthSans1;
}

/*------------------------------------------------------------------------------------------------
Description:
    Finds the "split index", which is the leaf node just prior to the one where the common 
    prefix in the nodes in the range changes.  The number of bits under consider depends on the 
    range, which is a function of node depth.

    Example tree (taken from by-hand calculations):
        Leaf0 = 0b00001
        Leaf1 = 0b00010
        Leaf2 = 0b00011
        Leaf3 = 0b01001
        Leaf4 = 0b01001
        Leaf5 = 0b01110
        Leaf6 = 0b01111

    N-1 internal nodes
    Internal node 0 covers the range 0-6, split is at Leaf2
    Internal node 1 covers the range 1-2, split is at Leaf1
    Internal node 2 covers the range 0-2, split is at Leaf0
    Internal node 3 covers the range 3-6, split is at Leaf4
    Internal node 4 covers the range 3-4, split is at Leaf3
    Internal node 5 covers the range 5-6, split is at Leaf5

    It is part of the binary radix tree generation described in this paper:
    http://devblogs.nvidia.com/parallelforall/wp-content/uploads/2012/11/karras2012hpg_paper.pdf

    Like DetermineRange(...), this is only called once by main(), but I thought that it made the 
    algorithm easier to read if this part of it was off in its own function.

Parameters: 
    startNodeIndex  An index into the internal node section of the BvhNodeBuffer.
    length          See DetermineRange(...) Description.
    direction       -1 or +1.  If it is 0, something has gone terribly wrong.
Returns:    
    The number of leaf nodes that are below this internal node in the hierarchy.
Creator:    John Cox, 5/2017
------------------------------------------------------------------------------------------------*/
int FindSplitPosition(int startNodeIndex, int length, int direction)
{
    int otherEndIndex = startNodeIndex + (length * direction);
    int commonPrefixLengthBetweenBeginAndEnd = LengthOfCommonPrefix(startNodeIndex, otherEndIndex);
    int splitOffset = 0;

    // Note: The loop should run through rangeIncrement == 1, dividing in half each time (log2 
    // ranging search), but calling ceil(...) with anything on the range [0,1] will return 1.  
    // A do-while(...) loop will work nicely here and avoid an infinite loop.
    float rangeIncrement = length;
    do
    {
        // cut the increment in half on each loop
        rangeIncrement = ceil(rangeIncrement * 0.5f);
        //rangeIncrement = ceil(rangeIncrement / 2.0f);
        //int rangeIncrementInteger = int(rangeIncrement + 0.001f);
        int rangeIncrementInteger = int(rangeIncrement);
        int secondNodeIndex = startNodeIndex + ((splitOffset + rangeIncrementInteger) * direction);
        if (LengthOfCommonPrefix(startNodeIndex, secondNodeIndex) > commonPrefixLengthBetweenBeginAndEnd)
        {
            splitOffset += rangeIncrementInteger;
        }
    } while (rangeIncrement > 1.0f);

    int splitIndex = startNodeIndex + (splitOffset * direction) + min(direction, 0);

    return splitIndex;
}


// TODO: remove this
void ResetDebugStructures(uint nodeIndex)
{
//    AllBvhNodes[nodeIndex]._signDebug._d = 0;
//    AllBvhNodes[nodeIndex]._signDebug._before._indexA = -1;
//    AllBvhNodes[nodeIndex]._signDebug._before._valueA = 0;
//    AllBvhNodes[nodeIndex]._signDebug._before._indexB = -1;
//    AllBvhNodes[nodeIndex]._signDebug._before._valueB = 0;
//    AllBvhNodes[nodeIndex]._signDebug._before._commonPrefixLength = 0;
//    AllBvhNodes[nodeIndex]._signDebug._after._indexA = -1;
//    AllBvhNodes[nodeIndex]._signDebug._after._valueA = 0;
//    AllBvhNodes[nodeIndex]._signDebug._after._indexB = -1;
//    AllBvhNodes[nodeIndex]._signDebug._after._valueB = 0;
//    AllBvhNodes[nodeIndex]._signDebug._after._commonPrefixLength = 0;

//    for (int i = 0; i < 25; i++)
//    {
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._minPrefix._indexA = -1;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._minPrefix._valueA = 0;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._minPrefix._indexB = -1;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._minPrefix._valueB = 0;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._minPrefix._commonPrefixLength = 0;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._iterations[i]._lengthBefore = 0;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._iterations[i]._prefixLength._indexA = -1;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._iterations[i]._prefixLength._valueA = 0;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._iterations[i]._prefixLength._indexB = -1;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._iterations[i]._prefixLength._valueB = 0;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._iterations[i]._prefixLength._commonPrefixLength = 0;
//        AllBvhNodes[nodeIndex]._findMaxLengthDebug._iterations[i]._lengthAfter = 0;
//        
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._minPrefix._indexA = -1;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._minPrefix._valueA = 0;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._minPrefix._indexB = -1;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._minPrefix._valueB = 0;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._minPrefix._commonPrefixLength = 0;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._iterations[i]._lengthBefore = 0;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._iterations[i]._prefixLength._indexA = -1;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._iterations[i]._prefixLength._valueA = 0;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._iterations[i]._prefixLength._indexB = -1;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._iterations[i]._prefixLength._valueB = 0;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._iterations[i]._prefixLength._commonPrefixLength = 0;
//        AllBvhNodes[nodeIndex]._findOtherEndDebug._iterations[i]._lengthAfter = 0;
//    }

    AllBvhNodes[nodeIndex]._extraData1 = -1;
    AllBvhNodes[nodeIndex]._extraData2 = -1;
}





/*------------------------------------------------------------------------------------------------
Description:
    Performs a parallel construction of a binary radix tree.

    The algorithm has been adapted from this paper to OpenGL compute shaders:
    http://devblogs.nvidia.com/parallelforall/wp-content/uploads/2012/11/karras2012hpg_paper.pdf

    Other influence came from the article that linked to the paper:
    https://devblogs.nvidia.com/parallelforall/thinking-parallel-part-iii-tree-construction-gpu/

    This algorithm has been worked through by hand and followed by a CPU implementation before 
    creating this compute shader version.
Creator:    John Cox, 5/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    // Note: For N leaves there are n-1 internal nodes, hence the -1.
    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex >= uParticleBufferSize ||
        threadIndex >= (uNumActiveParticles - 1))
    {
        // all inactive particles are sorted to the back of the particle buffer, so returning 
        // now won't leave a gap in the tree
        return;
    }

    // Note: This algorithm invloves lots of index calculations that must be allowed to go 
    // negative.  For example, the function LengthOfCommonPrefix(...) will return -1 if the 
    // second index is out of range.  That is an important part of the range calculation.
    int thisLeafIndex = int(threadIndex);
    int thisInternalNodeIndex = int(uBvhNumberLeaves + threadIndex);
    int rootInternalNodeIndex = int(uBvhNumberLeaves);

    //AllBvhNodes[thisLeafIndex]._threadEntranceCounter = 13;

    //AllBvhNodes[thisInternalNodeIndex]._parentIndex = -1;
    AllBvhNodes[thisInternalNodeIndex]._threadEntranceCounter = 0;
    
    
    //// TODO: remove this
    //atomicAdd(AllBvhNodes[thisInternalNodeIndex]._extraData1, 1);



    // TODO: remove this
    //ResetDebugStructures(uBvhNumberLeaves + threadIndex);



    // build the tree
    int commonPrefixLengthBefore = LengthOfCommonPrefix(thisLeafIndex, thisLeafIndex - 1);
    int commonPrefixLengthAfter = LengthOfCommonPrefix(thisLeafIndex, thisLeafIndex + 1);

    // if I made LengthOfCommonPrefix(...) correctly, this should never return 0
    // Note: If direction is 0, then something has gone terribly wrong.
    int d = sign(commonPrefixLengthAfter - commonPrefixLengthBefore);

//    uint val1 = 0;
//    uint val2 = 0;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._d = d;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._before._indexA = thisLeafIndex;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._before._indexB = thisLeafIndex - 1;
//    val1 = AllBvhNodes[thisLeafIndex]._data;
//    val2 = AllBvhNodes[thisLeafIndex - 1]._data;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._before._valueA = val1;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._before._valueB = val2;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._before._xor = val1 ^ val2;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._before._commonPrefixLength = commonPrefixLengthBefore;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._after._indexA = thisLeafIndex;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._after._indexB = thisLeafIndex + 1;
//    val1 = AllBvhNodes[thisLeafIndex]._data;
//    val2 = AllBvhNodes[thisLeafIndex + 1]._data;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._after._valueA = val1;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._after._valueB = val2;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._after._xor = val1 ^ val2;
//    AllBvhNodes[thisInternalNodeIndex]._signDebug._after._commonPrefixLength = commonPrefixLengthAfter;



    int range = DetermineRange(thisLeafIndex, d);
    int splitIndex = FindSplitPosition(thisLeafIndex, range, d);
    
    // already calculated in FindSplitPosition(...), but it's already returning a value and this 
    // calculation is cheap and it's needed, so do it again
    int otherEndIndex = thisLeafIndex + (range * d);

    AllBvhNodes[thisInternalNodeIndex]._startIndex = thisLeafIndex;
    AllBvhNodes[thisInternalNodeIndex]._endIndex = otherEndIndex;
    AllBvhNodes[thisInternalNodeIndex]._leafSplitIndex = splitIndex;

    int leftChildIndex = -12;
    if (min(thisLeafIndex, otherEndIndex) == splitIndex)
    {
        // left child is a leaf node
        leftChildIndex = splitIndex;
    }
    else
    {
        // left child is an internal node
        leftChildIndex = rootInternalNodeIndex + splitIndex;
    }
    AllBvhNodes[thisInternalNodeIndex]._leftChildIndex = leftChildIndex;

    int rightChildIndex = -12;
    if (max(thisLeafIndex, otherEndIndex) == (splitIndex + 1))
    {
        // right child is a leaf node
        rightChildIndex = splitIndex + 1;
    }
    else
    {
        // right child is an internal node
        rightChildIndex = rootInternalNodeIndex + splitIndex + 1;
    }
    AllBvhNodes[thisInternalNodeIndex]._rightChildIndex = rightChildIndex;

    // in the next stage (constructing the bounding volumes out of this new tree's hierarchy), 
    // both nodes need the option of traversing up to their parent
    // Note: This should set both leaf node and internal parent indices.
    // Also Note: If this algorithm is working correctly, then all internal nodes should have 
    // exactly 2 children, so there should be no need for an "index is -1" check.
    AllBvhNodes[leftChildIndex]._parentIndex = thisInternalNodeIndex;
    AllBvhNodes[rightChildIndex]._parentIndex = thisInternalNodeIndex;
}

