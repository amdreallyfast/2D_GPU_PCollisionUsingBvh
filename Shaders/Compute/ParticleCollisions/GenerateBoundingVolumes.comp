// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
// REQUIRES BvhNodeBuffer.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;



/*------------------------------------------------------------------------------------------------
Description:
    This shader generates bounding boxes for each of the leaves, then works up the tree to the 
    root, merging bounding boxes as they go.  Only one thread is allowed to do the merging of 
    two child nodes at a time, so the number of active threads decreases as they go up the 
    chain.  This shouldn't be much of a performance problem though because the algorithm is 
    simple and fast and only goes through log2N iterations at most (16 for 50,000 particles 
    (leaves), 20 for 1,000,000 particles).

    This comes as part of this BVH algorithm, specifically the section 
    "Bounding Box Calculation":
    https://devblogs.nvidia.com/parallelforall/thinking-parallel-part-iii-tree-construction-gpu/

    This algorithm has been worked through by hand and followed by a CPU implementation before 
    creating this compute shader version.
Creator:    John Cox, 5/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    // all the leaf nodes are at the front of the BvhNodeBuffer, sharing the same indices with 
    // the particles, so this same index can be used for both ParticleBuffer access and 
    // BvhNodeBuffer access
    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex >= uParticleBufferSize ||
        threadIndex >= uNumActiveParticles)
    {
        // thread greater than data set size or no leaf was made for this particle
        return;
    }

    // create the leaf's bounding box
    vec4 pos = AllParticles[threadIndex]._pos;
    float r = AllParticles[threadIndex]._collisionRadius;
    
    AllBvhNodes[threadIndex]._boundingBox._left = pos.x - r;
    AllBvhNodes[threadIndex]._boundingBox._right = pos.x + r;
    AllBvhNodes[threadIndex]._boundingBox._bottom = pos.y - r;
    AllBvhNodes[threadIndex]._boundingBox._top = pos.y + r;

    int ohCrapOhCrapCounter = 0;

    // now go up through the internal nodes and merge the bounding boxes until the root
    // Note: The parent index should only be -1 at the root node.
    int nodeIndex = AllBvhNodes[threadIndex]._parentIndex;
    while(nodeIndex != -1 && ohCrapOhCrapCounter < 25)
    {
        ohCrapOhCrapCounter++;

        // prevent race conditions to the parent node
        // Note: This suggestion comes the source material given in main()'s comment block.  
        // "To avoid duplicate work, the idea is to use an atomic flag per node to terminate the 
        // first thread that enters it, while letting the second one through. This ensures that 
        // every node gets processed only once, and not before both of its children are 
        // processed."
        atomicAdd(AllBvhNodes[nodeIndex]._threadEntranceCounter, 1);
        if (AllBvhNodes[nodeIndex]._threadEntranceCounter == 1)
        {
            return;
        }
        
        int leftChildIndex = AllBvhNodes[nodeIndex]._leftChildIndex;
        int rightChildIndex = AllBvhNodes[nodeIndex]._rightChildIndex;
        BoundingBox leftBb = AllBvhNodes[leftChildIndex]._boundingBox;
        BoundingBox rightBb = AllBvhNodes[rightChildIndex]._boundingBox;

        AllBvhNodes[nodeIndex]._boundingBox._left = min(leftBb._left, rightBb._left);
        AllBvhNodes[nodeIndex]._boundingBox._right = max(leftBb._right, rightBb._right);
        AllBvhNodes[nodeIndex]._boundingBox._bottom = min(leftBb._bottom, rightBb._bottom);
        AllBvhNodes[nodeIndex]._boundingBox._top = max(leftBb._top, rightBb._top);

        nodeIndex = AllBvhNodes[nodeIndex]._parentIndex;
    }


    // TODO: remove this
    if (nodeIndex != -1)
    {
        AllBvhNodes[0]._extraData1 = nodeIndex;
        AllBvhNodes[0]._extraData2 = ohCrapOhCrapCounter;
    }
    
}




