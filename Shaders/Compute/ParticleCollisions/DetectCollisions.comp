// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
// REQUIRES BvhNodeBuffer.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;



// TODO: header
float OverlappingArea(int node1Index, int node2Index)
{
    float overlapBoxLeft = max(
        AllBvhNodes[node1Index]._boundingBox._left, 
        AllBvhNodes[node2Index]._boundingBox._left);
    float overlapBoxRight = min(
        AllBvhNodes[node1Index]._boundingBox._right, 
        AllBvhNodes[node2Index]._boundingBox._right);
    float overlapBoxBottom = max(
        AllBvhNodes[node1Index]._boundingBox._bottom, 
        AllBvhNodes[node2Index]._boundingBox._bottom);
    float overlapBoxTop = min(
        AllBvhNodes[node1Index]._boundingBox._top, 
        AllBvhNodes[node2Index]._boundingBox._top);

    float width = overlapBoxRight - overlapBoxLeft;
    float height = overlapBoxTop - overlapBoxBottom;
    float overlapArea = (width < 0.0f || height < 0.0f) ? 0.0f : width * height;
    return overlapArea;
}



/*------------------------------------------------------------------------------------------------
Description:
    Navigates the Bounding Volume Hierarchy (BVH) and finds overlapping collision boxes.  When there are thousands of particles on-screen at a time, there may be many bounding box overlaps for any one particle.  The priorty collision will be the bounding box with the greatest overlap.

    Influence for the tree traversal comes from here, specifically the section entitled
    "Minimizing Divergence":
    https://devblogs.nvidia.com/parallelforall/thinking-parallel-part-ii-tree-traversal-gpu/

    For elastic collisions between two different masses (ignoring rotation because these 
    particles are points), use the calculations from this article (I followed them on paper too 
    and it seems legit)
    http://www.gamasutra.com/view/feature/3015/pool_hall_lessons_fast_accurate_.php?page=3

    Note: For an elastic collision between two particles of equal mass, the velocities of the 
    two will be exchanged.  I could use this simplified idea for this demo, but I want to 
    eventually have the option of different masses of particles, so I will use the general 
    case elastic collision calculations (bottom of page at link).
    http://hyperphysics.phy-astr.gsu.edu/hbase/colsta.html

Parameters: None
Returns:    None
Creator:    John Cox, 4/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex >= uParticleBufferSize ||
        threadIndex >= uNumActiveParticles)
    {
        // no collisions for inactive particles (they were left out of the BVH anyway)
        return;
    }

    AllParticles[threadIndex]._numberOfNearbyParticles = 0;

    // because OverlappingArea(...) takes signed integers for indices, which in turn is because 
    // all the BVH's nodes use signed integers for indices
    int thisLeafNodeIndex = int(threadIndex);

    int numberOfPotentialCollisions = 0;
    float areaOfGreatestOverlap = 0.0f;
    int particleIndexWithGreatestOverlap = -1;

    // iterative traversal of the tree requires keeping track of the depth yourself
    int topOfStackIndex = 0;
    // TODO: ??would not initializing this speed it up??
    const int MAX_STACK_SIZE = 64;
    int nodeStack[MAX_STACK_SIZE];
    nodeStack[topOfStackIndex++] = -1;  // "top of stack"

    // start at root internal node    
    // Note: By definition of the BVH's construction, all bounding boxes are contained within 
    // the root node's bounding box, so don't bother checking for overlap with the root.
    int currentNodeIndex = int(uBvhNumberLeaves);
    do
    {
        // check for overlap with leaf node (another particle) on the left
        int leftChildIndex = AllBvhNodes[currentNodeIndex]._leftChildIndex;
        float overlapAreaLeft = OverlappingArea(thisLeafNodeIndex, leftChildIndex);
        bool overlapLeft = (overlapAreaLeft > 0.0f);
        bool leftChildIsNotSelf = (leftChildIndex != thisLeafNodeIndex);
        bool leftChildIsLeaf = (AllBvhNodes[leftChildIndex]._isLeaf == 1);
        if (overlapLeft && leftChildIsNotSelf && leftChildIsLeaf)
        {
            numberOfPotentialCollisions++;
            particleIndexWithGreatestOverlap = leftChildIndex;
            break;
            if (overlapAreaLeft > areaOfGreatestOverlap)
            {
                areaOfGreatestOverlap = overlapAreaLeft;
                particleIndexWithGreatestOverlap = leftChildIndex;
            }
        }

        // repeat for the right branch
        int rightChildIndex = AllBvhNodes[currentNodeIndex]._rightChildIndex;
        float overlapAreaRight = OverlappingArea(thisLeafNodeIndex, rightChildIndex);
        bool overlapRight = (overlapAreaRight > 0.0f);
        bool rightChildIsNotSelf = (rightChildIndex != thisLeafNodeIndex);
        bool rightChildIsLeaf = (AllBvhNodes[rightChildIndex]._isLeaf == 1);
        if (overlapRight && rightChildIsNotSelf && rightChildIsLeaf)
        {
            numberOfPotentialCollisions++;
            particleIndexWithGreatestOverlap = rightChildIndex;
            break;
            if (overlapAreaRight > areaOfGreatestOverlap)
            {
                areaOfGreatestOverlap = overlapAreaRight;
                particleIndexWithGreatestOverlap = rightChildIndex;
            }
        }

        // next node
        // Note: By virtue of the BVH's construction, the only nodes with child indices of 
        // -1 will be leaf nodes.  Leaf checks were already done, so no need to perform 
        // "child index == -1" checks.
        bool traverseLeft = (overlapLeft && !leftChildIsLeaf);
        bool traverseRight = (overlapRight && !rightChildIsLeaf);
        if (!traverseLeft && !traverseRight)
        {
            // children must be leaves, non-overlapping, or both; pop the top of the stack
            currentNodeIndex = nodeStack[--topOfStackIndex];
        }
        else 
        {
            // at least one of the nodes is not a leaf
            currentNodeIndex = traverseLeft ? leftChildIndex : rightChildIndex;
            if (traverseLeft && traverseRight)
            {
                // neither is a leaf;  already traversing left, so push the right index
                nodeStack[topOfStackIndex++] = rightChildIndex;
            }
        }
    } while (currentNodeIndex != -1 && topOfStackIndex < MAX_STACK_SIZE);

    // for color
    AllParticles[thisLeafNodeIndex]._numberOfNearbyParticles = numberOfPotentialCollisions;
    
    if (particleIndexWithGreatestOverlap != -1)
    {
        // the bounding boxes overlapped, but particles have circular collision regions
        float r1 = AllParticles[thisLeafNodeIndex]._collisionRadius;
        float r2 = AllParticles[particleIndexWithGreatestOverlap]._collisionRadius;
        float minDistForCollisionSqr = (r1 + r2) * (r1 + r2);

        // partial pythagorean theorem so that I don't have to take the square root
        // Note: Only pluck out the positional information for these calculations.  Ignore the W 
        // component of the position.  It should end up as 0 after the subtraction, but force it to 
        // 0 just in case.
        vec4 p1Pos = AllParticles[thisLeafNodeIndex]._pos;
        vec4 p2Pos = AllParticles[particleIndexWithGreatestOverlap]._pos;
        vec4 p1ToP2 = vec4(p2Pos.xyz - p1Pos.xyz, 0.0f);
        float distP1ToP2Sqr = dot(p1ToP2, p1ToP2);
    
        if (distP1ToP2Sqr > minDistForCollisionSqr)
        {
            // close, but no cigar
            particleIndexWithGreatestOverlap = -1;
        }
    }
    AllParticles[thisLeafNodeIndex]._collideWithThisParticleIndex = particleIndexWithGreatestOverlap;

    AllBvhNodes[thisLeafNodeIndex]._extraData1 = numberOfPotentialCollisions;

}

