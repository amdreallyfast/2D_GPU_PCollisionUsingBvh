// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
// REQUIRES BvhNodeBuffer.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;

/*------------------------------------------------------------------------------------------------
Description:
    The binary radix tree (framework of the BVH) is created by analyzing the data over which the 
    leaf notes were sorted.  In this demo, leaves are equivalent to particles.  They are 
    different structures to make bounding box overlaps easier, but being different structures 
    means that they need to be initialized prior to construction of the tree.
Creator:    John Cox, 5/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    // all the leaf nodes are at the front of the BvhNodeBuffer, sharing the same indices with 
    // the particles, so this same index can be used for both ParticleBuffer access and 
    // BvhNodeBuffer access
    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex >= uParticleBufferSize)
    {
        return;
    }
    
    if (AllParticles[threadIndex]._isActive == 0)
    {
//        AllBvhNodes[threadIndex]._boundingBox._left = -0.15f;
//        AllBvhNodes[threadIndex]._boundingBox._right = +0.15f;
//        AllBvhNodes[threadIndex]._boundingBox._bottom = -0.12f;
//        AllBvhNodes[threadIndex]._boundingBox._top = +0.12f;
        AllBvhNodes[threadIndex]._boundingBox._left = 0.0f;
        AllBvhNodes[threadIndex]._boundingBox._right = 0.0f;
        AllBvhNodes[threadIndex]._boundingBox._bottom = 0.0f;
        AllBvhNodes[threadIndex]._boundingBox._top = 0.0f;
        return;
    }

    // set the data that will be be analyzed on tree construction
    AllBvhNodes[threadIndex]._data = AllParticles[threadIndex]._mortonCode;

    // and create the bounding box for the bounding volume hierarchy
    vec4 pos = AllParticles[threadIndex]._pos;
    //pos.x = pos.x + (0.01f * threadIndex);
    float r = AllParticles[threadIndex]._collisionRadius;

    AllBvhNodes[threadIndex]._boundingBox._left = pos.x - r;
    AllBvhNodes[threadIndex]._boundingBox._right = pos.x + r;
    AllBvhNodes[threadIndex]._boundingBox._bottom = pos.y - r;
    AllBvhNodes[threadIndex]._boundingBox._top = pos.y + r;
//    AllBvhNodes[threadIndex]._boundingBox._left = -0.03f;
//    AllBvhNodes[threadIndex]._boundingBox._right = +0.03f;
//    AllBvhNodes[threadIndex]._boundingBox._bottom = -0.03f;
//    AllBvhNodes[threadIndex]._boundingBox._top = +0.03f;

    
    //// TODO: remove
    //AllBvhNodes[threadIndex]._extraData2 = AllParticles[threadIndex]._isActive;
    //if (AllParticles[threadIndex]._isActive != 1)
    //{
    //    AllBvhNodes[threadIndex]._extraData2 = 37;
    //}
    
}
    