// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// - PARALLEL_SORT_WORK_GROUP_SIZE_X
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
// REQUIRES BvhNodeBuffer.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;



/*------------------------------------------------------------------------------------------------
Description:
    Algorithm from (??paper??) and (??Thinking Parallel??)
Creator:    John Cox, 5/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex >= uParticleBufferSize)
    {
        return;
    }

    // ??is this section strictly necessary??
    Node leafNode = AllBvhNodes[uBvhNumberInternalNodes + threadIndex];
    leafNode._leftChildNodeIndex = -1;
    leafNode._rightChildNodeIndex = -1;
    leafNode._isLeaf = true;
    leafNode._particleIndex = threadIndex;
    AllBvhNodes[uBvhNumberInternalNodes + threadIndex] = leafNode;

    // build the internal nodes
    // Note: There are n-1 internal nodes, so need to shave off one more thread.
    if (threadIndex >= (uParticleBufferSize - 1)
    {
        return;
    }

    do the thing
}