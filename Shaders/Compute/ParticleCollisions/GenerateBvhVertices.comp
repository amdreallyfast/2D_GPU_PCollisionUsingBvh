// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
// REQUIRES PolygonBuffer.comp
// REQUIRES BvhNodeBuffer.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;


/*------------------------------------------------------------------------------------------------
Description:
    This shader creates lines for each side of the bounding boxes for leaves and for internal 
    nodes.  This creates an outline visualization for the BVH.
    
    Note: Hopefully help me to figure out why some particles are flickering like they were 
    unable to traverse the tree all of a sudden and for 1 frame only.  
    
    But as of Sat, 5/20-2017, at 11:49AM, it hasn't helped. - John Cox
Parameters: None
Returns:    None
Creator:    John Cox, 4/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    // all the leaf nodes are at the front of the BvhNodeBuffer, sharing the same indices with 
    // the particles, so this same index can be used for both ParticleBuffer access and 
    // BvhNodeBuffer access
    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex >= uParticleBufferSize)
    {
        // thread greater than data set size or no leaf was made for this particle
        return;
    }
    
    BoundingBox bb;
    PolygonFace leftFace;
    PolygonFace rightFace;
    PolygonFace topFace;
    PolygonFace bottomFace;

    uint leafNodeIndex = threadIndex;
    uint internalNodeIndex = uBvhNumberLeaves + threadIndex;

    // clear out the polygons for the nodes of inactive particles
    // Note: The geometry rendering will draw all possible vertices, so make sure that leaf 
    // nodes that don't correspond to active particles are given null data.
    if (AllParticles[leafNodeIndex]._isActive == 0)
    {
        return; 
        AllPolygons[(leafNodeIndex * 4) + 0] = leftFace;
        AllPolygons[(leafNodeIndex * 4) + 1] = rightFace;
        AllPolygons[(leafNodeIndex * 4) + 2] = topFace;
        AllPolygons[(leafNodeIndex * 4) + 3] = bottomFace;

        // recall that, for a maximum N leaves, there are a maximum N-1 internal nodes
        if (leafNodeIndex < (uBvhNumberLeaves - 1))
        {
            AllPolygons[(internalNodeIndex * 4) + 0] = leftFace;
            AllPolygons[(internalNodeIndex * 4) + 1] = rightFace;
            AllPolygons[(internalNodeIndex * 4) + 2] = topFace;
            AllPolygons[(internalNodeIndex * 4) + 3] = bottomFace;
        }

        return;
    }

    // the particle for this node is active, so make the 4 faces of the bounding box
    bb = AllBvhNodes[leafNodeIndex]._boundingBox;
    leftFace._start._pos = vec4(bb._left, bb._bottom, 0.0f, 1.0f);
    leftFace._end._pos = vec4(bb._left, bb._top, 0.0f, 1.0f);
    rightFace._start._pos = vec4(bb._right, bb._bottom, 0.0f, 1.0f);
    rightFace._end._pos = vec4(bb._right, bb._top, 0.0f, 1.0f);
    topFace._start._pos = vec4(bb._left, bb._top, 0.0f, 1.0f);
    topFace._end._pos = vec4(bb._right, bb._top, 0.0f, 1.0f);
    bottomFace._start._pos = vec4(bb._left, bb._bottom, 0.0f, 1.0f);
    bottomFace._end._pos = vec4(bb._right, bb._bottom, 0.0f, 1.0f);

    // 4 faces per bounding box
    AllPolygons[(leafNodeIndex * 4) + 0] = leftFace;
    AllPolygons[(leafNodeIndex * 4) + 1] = rightFace;
    AllPolygons[(leafNodeIndex * 4) + 2] = topFace;
    AllPolygons[(leafNodeIndex * 4) + 3] = bottomFace;

//    // do the same for the internal node with this index
//    if (leafNodeIndex < (uNumActiveParticles - 1))
//    {
//        bb = AllBvhNodes[internalNodeIndex]._boundingBox;
//        leftFace._start._pos = vec4(bb._left, bb._bottom, 0.0f, 1.0f);
//        leftFace._end._pos = vec4(bb._left, bb._top, 0.0f, 1.0f);
//        rightFace._start._pos = vec4(bb._right, bb._bottom, 0.0f, 1.0f);
//        rightFace._end._pos = vec4(bb._right, bb._top, 0.0f, 1.0f);
//        topFace._start._pos = vec4(bb._left, bb._top, 0.0f, 1.0f);
//        topFace._end._pos = vec4(bb._right, bb._top, 0.0f, 1.0f);
//        bottomFace._start._pos = vec4(bb._left, bb._bottom, 0.0f, 1.0f);
//        bottomFace._end._pos = vec4(bb._right, bb._bottom, 0.0f, 1.0f);
//
//        // 4 faces per bounding box
//        AllPolygons[(internalNodeIndex * 4) + 0] = leftFace;
//        AllPolygons[(internalNodeIndex * 4) + 1] = rightFace;
//        AllPolygons[(internalNodeIndex * 4) + 2] = topFace;
//        AllPolygons[(internalNodeIndex * 4) + 3] = bottomFace;
//    }
}