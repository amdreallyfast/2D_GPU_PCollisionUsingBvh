// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES SsboBufferBindings.comp
// REQUIRES PrefixScanBuffer.comp.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARALLEL_SORT_WORK_GROUP_SIZE_X) in;

shared uint[PARALLEL_SORT_ITEMS_PER_WORK_GROUP] fastTempArr;

/*------------------------------------------------------------------------------------------------
Description:
    This is the second half of the parallel prefix scan algorithm.  See description of 
    PrefixScanBuffer for more detail.

    See ParallelPrefixScanOverAllData.comp for comments on this algorithm.
Parameters: None
Returns:    None
Creator:    John Cox, 5/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    uint doubleGroupThreadIndex = gl_LocalInvocationID.x * 2;
    uint doubleGlobalThreadIndex = gl_GlobalInvocationID.x * 2;

    fastTempArr[doubleGroupThreadIndex] = PrefixSumsOfWorkGroupSums[doubleGlobalThreadIndex];
    fastTempArr[doubleGroupThreadIndex + 1] = PrefixSumsOfWorkGroupSums[doubleGlobalThreadIndex + 1];

    uint indexMultiplierDueToDepth = 1;

    for (uint dataPairs = PARALLEL_SORT_ITEMS_PER_WORK_GROUP >> 1; dataPairs > 0; dataPairs >>= 1)
    {
        barrier();
        if (gl_LocalInvocationID.x < dataPairs)
        {
            uint lesserIndex = (indexMultiplierDueToDepth * (doubleGroupThreadIndex + 1)) - 1;
            uint greaterIndex = (indexMultiplierDueToDepth * (doubleGroupThreadIndex + 2)) - 1;

            fastTempArr[greaterIndex] += fastTempArr[lesserIndex];
        }

        indexMultiplierDueToDepth *= 2;
    }

    // only one thread should do these (prevents unnecessary writes)
    if (doubleGroupThreadIndex == 0)
    {
        totalNumberOfOnes = PrefixSumsOfWorkGroupSums[PARALLEL_SORT_ITEMS_PER_WORK_GROUP - 1];
        fastTempArr[PARALLEL_SORT_ITEMS_PER_WORK_GROUP - 1] = 0;
    }
    indexMultiplierDueToDepth >>= 1;

    for (uint dataPairs = 1; dataPairs < PARALLEL_SORT_ITEMS_PER_WORK_GROUP; dataPairs *= 2)
    {
        barrier();
        if (gl_LocalInvocationID.x < dataPairs)
        {
            uint lesserIndex = (indexMultiplierDueToDepth * (doubleGroupThreadIndex + 1)) - 1;
            uint greaterIndex = (indexMultiplierDueToDepth * (doubleGroupThreadIndex + 2)) - 1;

            uint temp = fastTempArr[lesserIndex];
            fastTempArr[lesserIndex] = fastTempArr[greaterIndex];
            fastTempArr[greaterIndex] += temp;
        }
        indexMultiplierDueToDepth >>= 1;
    }

    // wait for all the group threads to finish, then write back the two items
    barrier();
    PrefixSumsOfWorkGroupSums[doubleGlobalThreadIndex] = fastTempArr[doubleGroupThreadIndex];
    PrefixSumsOfWorkGroupSums[doubleGlobalThreadIndex + 1] = fastTempArr[doubleGroupThreadIndex + 1];
}

