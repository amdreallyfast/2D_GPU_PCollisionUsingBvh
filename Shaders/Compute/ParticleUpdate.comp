// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// - PARALLEL_SORT_WORK_GROUP_SIZE_X
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
// REQUIRES ParticleRegionBoundaries.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;


// unlike SSBOs, atomic counter buffers seem to need a declaration like this and cannot be bound 
// dynamically as in ParticleSsbo and PolygonSsbo, so declare the atomic counters up front to 
// make it easier to keep the numbers straight.
// Note: Discovered by experience and through this: https://www.opengl.org/wiki/Atomic_Counter.
layout (binding = ATOMIC_COUNTER_BUFFER_BINDING, offset = 0) uniform atomic_uint acActiveParticleCounter;


//uniform vec4 uParticleRegionCenter;
//uniform float uParticleRegionRadiusSqr;
uniform float uDeltaTimeSec;

/*------------------------------------------------------------------------------------------------
Description:
    The compute shader's startup function.
Parameters: None
Returns:    None
Creator:    John Cox (9-25-2016)
------------------------------------------------------------------------------------------------*/
void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index >= uParticleBufferSize)
    {
        return;
    }

    Particle pCopy = AllParticles[index];
    pCopy._pos += (pCopy._vel * uDeltaTimeSec);

    // if it went out of bounds, turn it off and don't record the updated particle
    bool outOfBoundsX = pCopy._pos.x < PARTICLE_REGION_MIN_X || pCopy._pos.x > (PARTICLE_REGION_MIN_X + PARTICLE_REGION_RANGE_X);
    bool outOfBoundsY = pCopy._pos.y < PARTICLE_REGION_MIN_Y || pCopy._pos.y > (PARTICLE_REGION_MIN_Y + PARTICLE_REGION_RANGE_Y);
    bool outOfBoundsZ = pCopy._pos.z < PARTICLE_REGION_MIN_Z || pCopy._pos.z > (PARTICLE_REGION_MIN_Z + PARTICLE_REGION_RANGE_Z);
    //if (outOfBoundsX || outOfBoundsY || outOfBoundsZ)
    //{
    //    //pCopy._isActive = 0;
    //
    //}

    bool doNotUpdate = (pCopy._isActive == 0) || outOfBoundsX || outOfBoundsY || outOfBoundsZ;
    //if (pCopy._isActive == 0)
    //if (pCopy._isActive == 0 || deactivateParticle)
    if (doNotUpdate)
    {
        // make sure it's off (ex: just went out of bounds)
        AllParticles[index]._isActive = 0;
        return;
    }

    // only update active particles 

//    pCopy._pos += (pCopy._vel * uDeltaTimeSec);
//
//    // if it went out of bounds, turn it off
//    bool outOfBoundsX = pCopy._pos.x < PARTICLE_REGION_MIN_X || pCopy._pos.x > (PARTICLE_REGION_MIN_X + PARTICLE_REGION_RANGE_X);
//    bool outOfBoundsY = pCopy._pos.y < PARTICLE_REGION_MIN_Y || pCopy._pos.y > (PARTICLE_REGION_MIN_Y + PARTICLE_REGION_RANGE_Y);
//    bool outOfBoundsZ = pCopy._pos.z < PARTICLE_REGION_MIN_Z || pCopy._pos.z > (PARTICLE_REGION_MIN_Z + PARTICLE_REGION_RANGE_Z);
//    pCopy._isActive = (outOfBoundsX || outOfBoundsY || outOfBoundsZ) ? 0 : 1;

    // when the compute shader is summoned to update active particles, this counter will 
    // give a count of how many active particles exist
    atomicCounterIncrement(acActiveParticleCounter);

    // the particle moved, so let it have a chance to collide again
    pCopy._hasCollidedAlreadyThisFrame = 0;

    //// and re-count the number of nearby particles
    pCopy._numberOfNearbyParticles = 0;

    // copy the particle back into global memory
    AllParticles[index] = pCopy;
}

